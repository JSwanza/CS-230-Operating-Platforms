# CS-230-Operating-Platforms
Software design document
Project Summary
The client, The Gaming Room, already had an Android-only game called Draw It or Lose It, a timed drawing-and-guessing team game similar to Pictionary or Win, Lose or Draw. They wanted me to design a web-based version of the game that would run on multiple platforms (desktops and mobile devices) through browsers, allowing cross-device play, broader accessibility, and support for multiple teams with multiple players per team.
Strengths in Developing the Documentation
I believe I did particularly well in creating a clear, structured domain model using object-oriented principles. The UML class diagram and explanations of inheritance (Entity base class), composition (Game → Teams → Players), and the singleton pattern for GameService effectively showed how the core requirements—unique names, single active game instance, and hierarchical relationships—would be implemented. I also provided thoughtful, specific recommendations in the final section, tying together cross-platform concerns, storage, memory, distributed systems, and security with concrete technologies (Spring Boot, WebSockets, Redis, OAuth, etc.).
How the Design Document Helped When Developing the Code
Working through the design document forced me to think through the object hierarchy and constraints before writing any code. The domain model directly translated into the Java classes I later implemented, and planning the singleton GameService and iterator-based uniqueness checks upfront prevented me from having to refactor those parts later. The requirements and constraints sections also kept me focused on the client's key needs (single game instance, name uniqueness, multi-team support) while coding the prototype driver.
Part I Would Revise
If I could revise one part, I would complete the Evaluation section's comparison table for the different operating platforms (Windows, Mac, Linux) and mobile devices. The provided template asked for a detailed evaluation of each platform's characteristics, advantages, and weaknesses in the context of the web-based application, but I skipped filling in the table cells. Adding those paragraphs would have made the document more complete and demonstrated a deeper analysis of platform-specific considerations (e.g., browser compatibility, native features, deployment differences) that affect the final recommendation.
Interpreting and Implementing User Needs
I interpreted the user's needs by focusing on the explicit requirements: one active game instance, globally unique game names, unique team names within a game, multiple players per team, and cross-platform accessibility. These translated directly into design decisions—a singleton GameService to enforce the single-instance rule, iterator-based searches for name uniqueness before adding entities, and a web-based architecture using Java backend with browser-compatible frontend technologies. Considering the user's needs is critical because software is built to solve specific problems for specific people; ignoring them leads to features that are technically sound but practically unusable, wasted development effort, and unhappy clients.
Approach to Designing Software
I approached the design by starting with the domain model (identifying core entities and their relationships), applying object-oriented principles (inheritance, encapsulation, composition, singleton, iterator), and then evaluating architectural concerns (platforms, storage, memory, distribution, security). I used the provided template sections to ensure I covered requirements, constraints, and recommendations systematically. In the future, for similar applications I would continue using UML class diagrams early, create a singleton or centralized service for global constraints, prototype core logic in a simple driver before web integration, and explicitly include platform comparison tables or matrices when cross-platform support is a requirement. I would also add sequence or activity diagrams for key flows (like a timed round) to make real-time behavior even clearer.
